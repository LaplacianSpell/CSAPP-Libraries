# datalab

## bitOr

相当于用与非门实现或门，很经典的简化电路模型的问题，只需 `return ~((~x) & (~y))`;

## getByte

关键在于掩码的使用

首先计算 n bytes 对应的 bits 数目，乘 8，也即 `>> 3` 即可。

然后将目标数右移上述 bits 数目，把第 n 个 byte 移到最后一位，最后与掩码 `0xff` 与一下，把 lowest significant 的 byte 位取出来，也就相当于取出 n byte 的数字了。

## logicalShift

关键在于如何消掉负数算术右移中在 high significant bits 上补的 1.

假设需要右移动 n bits. 首先需要取出符号位，把 `0x1` 左移 31 位成为 0x 10 00 00 00，然后与 `x` 与一下就取出来了符号位。之后再右移 n-1 bits (不能用`-`只能右移 n 之后再左移 1)，然后再与算术右移产生的结果异或一下（保证 0 不变，把 1 变成 0）就弄出了逻辑右移。

## bitReverse

归并逆序，首先要构造出逆序使用的 bits 序列

用来交换 bits 长度为 1 的掩码：`0x55 55 55 55`

用来交换 bits 长度为 2 的掩码：`0x33 33 33 33`

用来交换 bits 长度为 4 的掩码：`0x0f 0f 0f 0f`

用来交换 bits 长度为 8 的掩码：`0x00 ff 00 ff`

用来交换 bits 长度为 16 的掩码：`0x 0000 ffff`

之后使用归并的方法逆序即可

## bang

关键在于看 bits 中有没有 1.也是采取归并的方法

首先是 `x >> 1 | x` 也就是将相邻的两个 bits 中是否有一个存在 1 的状态存储到 low significant bit 之中。之后便和上一题思路大致相同，都是右移 2 的倍数后与一下，最后只需要把最后一个 bits 的情况读取出来之后按照要求返回即可

## tmax

控制左移 `0xff` 的位置同时补齐 low significant bits 的 1.

## fitsBits*

首先通过右移 31 位获得与当前数字符号相关的一个掩码 `int sign`，如果是负数则为 `0xffffffff`，如果是正数则为 `0x00000000`.

然后获得当前数字的绝对值 (假)，首先 `x ^ sign` ，如果 `x` 为正数则依然是 x，如果 `x` 为负数则获得与 `-1-x`

对于 w bits 的宽度 能够容纳的范围是 $[-2^{w-1}, 2^{w-1}-1]$，那么对于我们构造的假绝对值，应该小于 $2^{w-1}$ 才能完整的放入其中，即检查 w-1 位及之后的位有没有 1

## dividerPower2*

对于正数，由于向下取整很自然的满足向 0 取整。关键在于负数，当不能除尽的时候（例如：产生 -12.125，由于约分之后产生了 -1/8）这样的数字就会不满足条件，那么我们只需要在原有的数字上加上一些偏差值，让约分之后这样的小数点不会产生或者是向后舍入与没加时向0舍入的结果相同即可.

对于负数的 $/2^n$ 的操作，能够产生的最小的小数是 $-0.5$，最大的小数是 $0$ 

那么我们在原数加上 $2^n - 1$ 相当于计算 $x/2^n + 1 - 1/2^n$ 之后再向下取整。使用 $2^n$ 将计算结果 $+1$ 使得向下舍入与原数向 0 舍入结果相同；同时使用 $-1$ 让当没有小数的时候加上 1 能再减几位，使得舍入之后回到正确的数字（同时最多只减 $0.5$，保证了即使原数计算结果小数为 $-0.5$，在$+1-0.5$之后也是刚刚好为向 0 舍入方向的数字）。

`(x >> 31) & (1 << n + ~0x0)` 前面一项保证正数情况不会影响，只会在负数的时候产生影响

## negate

公式 `-x = ~x + 1`

## isPositive*

由于正数和 0 的符号位都是 0，那么我们只需要取个相反数就好了，判断是不是负数。

取了相反数之后，向右移 31 位之后与掩码 `0x1` 做按位与，获得符号位是不是 1.

## isLessOrEqual

首先要考虑溢出的问题，我决定先右移动 31 位之后将结果按位异或获得 `isSame` 来判断符号，如果符号相同，则结果为 `0x0`，如果不同，则结果为 `0xffffffff`.

对于不同符号的条件 (用 isSame 与一下)，我们只需要判断 `x` 是不是负数即可，使用 `0x1 & xSign`，如果是负数，则返回 1，否则返回 0.

对于相同符号的条件 (用 isSame 取反后与一下)，我们需要先用 `y - x` 之后判断是不是负数 `!(((y + (~x + 1)) >> 31) & 0x1)`，如果是负数，则返回 0，否则返回 1.

把上面两个条件或一下，就得到了最终的结果。

## intLog2*

要求求出满足 $2^k < x$ 的最大整数 k，也就是求最高位的位权（右移 k 位之后变成 1）。

首先把最高位以下所有的数字填充为 1.只需要将 x 分别右移 2, 4, 8, 16 之后按位与即可。

然后统计 bits 中 x 的个数，只需要按照 `bitReverse` 中使用归并的方法即可

## floatIsEqual*

重点在于如何判断 denomarlized number，关键在于指数区域，首先右移 23 位取第一个字节给出指数区数。

如果 exp 数字全 0，则判断 frac 位置是否为全 0，如果为全 0，则直接相等，如果不是全 0，按位与（0- 与 0+）

如果 exp 全为 1，frac 不全为 0 时，直接返回 0。
